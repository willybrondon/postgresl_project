
       -- postgreSQL project done by NDANGUE WILLY Brondon--

-- creation of three tables wellbore, welllog and curve.
-- link wellbore and welllog table with wellname column as foreign key
-- link welllog and  curve table with id_welllog column as foriegn key
-- For the curve table find a SQL query to convert from the curve data array,
-- which is a JSONB array of values, into an array of float or date,
-- according to the real data type contained in the welllog1 data.


-- creation of the well_tmp table
create table welllog_tmp (
    id int generated always as identity primary key ,
    data jsonb
);
-- copy of the welllog_temp from the las json file
-- my data json file has been generated by pyhton script and then it has been copy
copy welllog_tmp(data) from PROGRAM 'python3 D:\ENSG\engs_lecture\lecture\exercise\lasio_to_json.py D:\ENSG\engs_lecture\data';
-- or we can copy it the file that you send directly:
--copy welllog_tmp(data) from '/Users/ndang/OneDrive/Bureau/Data_project/las_data.json';


-- creation of the wellore table
drop table if exists wellbore;
create table wellbore (
npdidwellbore text,
dscnpdiddiscovery text,
fldnpdidfield text,
fclnpdidfacilitydrilling text,
fclnpdidfacilityproducing text,
npdidwellborereclass text,
prlnpdidproductionlicence text,
wellborename text,
well text,
discovery text,
field text,
productionlicence text,
drillpermit text,
welltype text,
multilateral text,
wdssvolumereference text,
licensingactivity text,
drillingoperator text,
drillingfacility text,
facilitytypedrilling text,
productionfacility text,
entrydate text,
entryday text,
entrymonth text,
entryyear text,
completiondate text,
completionday text,
completionmonth text,
completionyear text,
nsdeg text,
nsmin text,
nssec text,
ewdeg text,
ewmin text,
ewsec text,
nsdecdeg text,
ewdesdeg text,
geodeticdatum text,
nsutm text,
ewutm text,
utmzone text,
ewcode text,
nscode text,
seismiclocation text,
plotsymbol text,
status text,
content text,
contentplanned text,
purpose text,
purposeplanned text,
mainarea text,
totaldepth text,
kellybushelevation text,
waterdepth text,
ageattd text,
drillingdays text,
reclassfromwellbore text,
reentryexplorationactivity text,
formationattd text,
bottomholetemperature text,
maxinclation text,
finalverticaldepth text,
formationwithhc1 text,
agewithhc1 text,
formationwithhc2 text,
agewithhc2 text,
formationwithhc3 text,
agewithhc3 text,
wdssqcdate text,
discoverywellbore text,
namepart1 text,
namepart2 text,
namepart3 text,
namepart4 text,
namepart5 text,
namepart6 text,
factpageurl text,
factmapurl text,
pressreleaseurl text,
diskoswellboretype text,
diskoswellboreparent text,
entrypredrilldate text,
comppredrilldate text,
releaseddate text,
reentry text,
withwellborehistory text,
withcuttings text,
withcores text,
withcorephoto text,
withpalyslides text,
withoilsamples text,
withcasingandlot text,
withmud text,
withdst text,
withlog text,
withformationtops text,
withcompositelog text,
withgeocheminfo text,
withdocreportedbylicensee text,
witholdwdss text,
withnpdpapers text,
coresampleavailable text,
cuttingssamplesavailable text,
dateupdated text,
dateupdatedmax text,
cmpnpdidcompany text,
cmpfactpageurl text,
fixed_or_moveable text,
subsea text,
kickoffpoint text,
licencetargetname text,
pluggeddate text,
pluggedabandondate text,
prlnpdidprodlicencetarget text,
npdidsitesurvey text,
sitesurvey text,
datereclass text,
pointgeometrywkt text

);
-- copy of the wellbore
copy wellbore from 'D:\ENSG\engs_lecture\data\test.csv' with (format csv , header true, delimiter ',');
-- done in 186 ms


-- creation of wellbore exploited as wellore1
create table wellbore1 as
(
    select id,
       jsonb_array_elements(data->'Well'
)->'descr'as descr,
       jsonb_array_elements(data->'Well')->'_type' as _type,
       jsonb_array_elements(data->'Well')->'value' as value,
       jsonb_array_elements(data->'Well')->'unit' as unit,
       jsonb_array_elements(data->'Well')->'mnemonic' as mnemonic
from welllog_tmp);



-- creation of welllog1 table : done in  2 s 957 ms
drop table welllog1;
create table welllog1 as
(
    select id,
        jsonb_array_element(data -> 'Well', 0) -> 'value' as start_index,
        jsonb_array_element(data -> 'Well', 4) -> 'value' as stop_index,
        jsonb_array_element(data -> 'Well', 3) -> 'value' as step,
        jsonb_array_element(data -> 'Well', 3) -> 'value' as NULL_VALUE,
        jsonb_array_element(data -> 'Well', 5) ->> 'value' as well_name,
        jsonb_array_element(data -> 'Well', 4) ->> 'value' as COMPANY,
        jsonb_array_element(data -> 'Well', 6) ->> 'value' as FIELD,
        jsonb_array_element(data -> 'Well', 7) ->> 'value' as LOCATION,
        jsonb_array_element(data -> 'Well', 11) ->> 'value' as COUNTRY,
        jsonb_array_element(data -> 'Well', 12) ->> 'value' as SERVIVE_COMPANY,
        jsonb_array_element(data -> 'Well', 13) -> 'value' as LOG_DATE


    from welllog_tmp
);



-- creation of the curve table : done in 4 s 942 ms
drop table if exists curve1;
create table curve1 as
(
    select id,
       jsonb_array_elements(data->'Well'
)->'descr'as descr,
       jsonb_array_elements(data->'Curves')->'_type' as _type,
       jsonb_array_elements(data->'Curves')->'value' as value,
       jsonb_array_elements(data->'Curves')->'unit' as unit,
       jsonb_array_elements(data->'Curves')->'mnemonic' as mnemonic,
       jsonb_array_elements(data -> 'Curves') -> 'data' as data
from welllog_tmp);


-- link of the three tables

                  -- linkage of two tables wellbore and welllog1 with well_name the foreign key--

-- first we need to drop coulumn id which is the primary kely of the wellbore table
-- because a table can only have one primary key
alter table wellbore drop column id;

-- then constraint wellborename as a primary key
alter table wellbore add constraint wellbore_pk primary key(wellborename);

-- now we link the two tables with the foreign primary key
alter table welllog1 add foreign key(well_name) references wellbore(wellborename);
                   -- but we get this error
-- La clé (well_name)=() n'est pas présente dans la table « wellbore ».
-- this error was predictable because the data of wellname of welllog1 and data of wellborename of wellbore don't match
-- may be you need to change the name of wellname from welllog to the ones from the wellbore


        -- link of welllog1 and curve1 table with the id_welllog1 ---

-- link of the two tables welllog1 and  curves
-- we set id column from the welllog1 table as a primary key
-- as we don't have primary key, we constraint primary key to the id column of welllog1 : done in 39 ms
alter table welllog1 add constraint welllog1_pk primary key(id);

-- now we link the two tables with the foreign primary key : done in 45 ms
alter table curve1 add foreign key(id) references welllog1(id);



                 -- Bonus ---

-- conversion of 0.0 float to integer 0 from the welllog1
select id,
        case when step is null then step :: float :: int else step :: float:: float end as step_zero_int
from wellog1;

-- Other way to convert 0.0 float to integer 0

select id,
        case when jsonb_typeof(step) = 'null' then step::float::int else step :: float:: float end as step
from wellog1;





-- creation of serial primary key on curve1 table id1
alter table curve1 add column id1 serial primary key;

-- convert one row of curve1 (contain a list) to a column (curve_data)
drop table if exists curve_data;
create table curve_data as
    ( select
        jsonb_array_elements(data)::text as data_text
        from curve1
        where id = 2
    );

--conversion  of null value (json type) to zero value from curve table

create table curve_data_zero as (
select
       case when data_text = 'null' then '0'
       else data_text :: float end as data_zero
from curve_data);

-- conversion of start_index json type to float or date/time
select id,
        case when jsonb_typeof (start_index) = 'number' then start_index::text::float else null end as start_index_number,
        case when jsonb_typeof(start_index) = 'string' then to_timestamp(replace(start_index::text, '"', ''), 'DD-MON-YYYY HH24:MI:SS') else null::timestamp end as start_index_timestamp,
        case when jsonb_typeof (stop_index) = 'number' then stop_index::text::float else null end as stop_index_number,
        case when jsonb_typeof(stop_index) = 'string' then to_timestamp(replace(stop_index::text, '"', ''), 'DD-MON-YYYY HH24:MI:SS') else null::timestamp end as stop_index_timestamp
from wellog1;
